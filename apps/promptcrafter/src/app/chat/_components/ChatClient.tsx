"use client";

import { useCallback, useEffect, useMemo, useRef, useState, type ReactNode } from "react";
import { Icon } from "@/components/Icon";
import FiltersSidebar from "./FiltersSidebar";
import { api } from "@/trpc/react";
import { isElectronRuntime } from '@/lib/runtime';
import Image from "next/image";
import { CustomSelect } from "@/components/CustomSelect";
import MessageFeedback from "@/components/MessageFeedback";

type Mode = "build" | "enhance";
type TaskType = "general" | "coding" | "image" | "research" | "writing" | "marketing";
type Tone = "neutral" | "friendly" | "formal" | "technical" | "persuasive";
type Detail = "brief" | "normal" | "detailed";
type Format = "plain" | "markdown" | "json";

interface MessageItem {
  id: string;
  role: "user" | "assistant";
  content: string;
  userFeedback?: 'like' | 'dislike';
}

type UserInfo = { name?: string | null; image?: string | null; email?: string | null };

interface ChatClientProps { user?: UserInfo }

export default function ChatClient({ user }: ChatClientProps) {
  // Utility to compose class names
  const cn = (...arr: Array<string | false | null | undefined>) => arr.filter(Boolean).join(" ");

  const [mode, setMode] = useState<Mode>("build");
  const [taskType, setTaskType] = useState<TaskType>("general");
  const [tone, setTone] = useState<Tone>("neutral");
  const [detail, setDetail] = useState<Detail>("normal");
  const [format, setFormat] = useState<Format>("markdown");
  const [language, setLanguage] = useState("English");
  const [temperature, setTemperature] = useState(0.7);
  // Type-specific
  const [stylePreset, setStylePreset] = useState("photorealistic");
  const [aspectRatio, setAspectRatio] = useState("1:1");
  const [includeTests, setIncludeTests] = useState(true);
  const [requireCitations, setRequireCitations] = useState(true);
  const [presetName, setPresetName] = useState("");
  const [presets, setPresets] = useState<Array<{ id?: string; name: string; mode: Mode; taskType: TaskType; options?: any }>>([]);
  const [loadingPresets, setLoadingPresets] = useState(false);
  const [selectedPresetKey, setSelectedPresetKey] = useState("");
  const [defaultPresetId, setDefaultPresetId] = useState<string | null>(null);
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<MessageItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [genDots, setGenDots] = useState(1);
  const [copiedId, setCopiedId] = useState<string | null>(null);
  const inputRef = useRef<HTMLTextAreaElement | null>(null);
  const MAX_INPUT_HEIGHT = 200;
  const [error, setError] = useState<string | null>(null);
  // Track whether a local model is configured (only then do we attempt streaming local generation)
  const [hasLocalModel, setHasLocalModel] = useState(false);
  // Sidebar is always open on desktop (md: >=768px). We still track state for mobile.
  const [sidebarOpen, setSidebarOpen] = useState(false);
  // Model display in header
  const [modelDisplay, setModelDisplay] = useState<string | null>(null);

  // Fetch model config for header banner
  useEffect(() => {
    const fetchModelDisplay = async () => {
      try {
        const res = await fetch('/api/model/config');
        const data = await res.json();
        const cfg = data?.config;
        if (!cfg) { setModelDisplay(null); return; }
        if (cfg.provider === 'openrouter-proxy') {
          setModelDisplay('API Gemma 3 27B');
          return;
        }
        if (cfg.provider === 'ollama' && typeof cfg.model === 'string') {
          const size = (cfg.model.split(':')[1] || '').toUpperCase();
          if (size) {
            setModelDisplay(`Local Gemma 3 ${size}`);
            return;
          }
        }
        setModelDisplay(null);
      } catch {
        setModelDisplay(null);
      }
    };
    fetchModelDisplay();
    const handler = () => fetchModelDisplay();
    window.addEventListener('MODEL_CHANGED', handler);
    return () => window.removeEventListener('MODEL_CHANGED', handler);
  }, []);

  // On first mount, open sidebar automatically if desktop viewport.
  useEffect(() => {
    if (typeof window !== 'undefined') {
      if (window.matchMedia('(min-width: 768px)').matches) {
        setSidebarOpen(true);
      }
    }
  }, []);
  const [accountOpen, setAccountOpen] = useState(false); // Saved Data modal
  const [infoOpen, setInfoOpen] = useState(false);
  const renderMessageContent = useCallback((text: string, messageId?: string) => {
    const trimmed = text.trim();

    // Special styling for rejection / guidance messages generated by prompt-builder
    if (/^User input rejected:/i.test(trimmed)) {
      return (
        <div className="rounded-lg border border-amber-500/40 bg-amber-900/30 px-3 py-2 text-amber-200 text-xs leading-relaxed">
          {trimmed.replace(/^User input rejected:\s*/i, '')}
        </div>
      );
    }

    if (/^NEED_CONTEXT\s+–/i.test(trimmed)) {
      return (
        <div className="rounded-md border border-blue-400/40 bg-blue-900/30 px-3 py-2 text-[11px] leading-relaxed text-blue-200">
          {trimmed.replace(/^NEED_CONTEXT\s+–\s*/i, '')}
        </div>
      );
    }

    // 1) If entire message is valid JSON (no fences), show as JSON code block
    const looksLikeJson = (s: string) => (s.startsWith("{") && s.endsWith("}")) || (s.startsWith("[") && s.endsWith("]"));
    if (looksLikeJson(trimmed)) {
      try {
        const parsed = JSON.parse(trimmed);
        const pretty = JSON.stringify(parsed, null, 2);
        return (
          <div className="message-prose max-w-none">
            <div className="my-2 overflow-hidden rounded-lg border border-white/10 bg-black/30">
              <div className="flex items-center justify-between border-b border-white/10 bg-black/20 px-3 py-1.5 text-[11px] text-gray-300">
                <span className="uppercase tracking-wider">json</span>
              </div>
              <pre className="overflow-x-auto p-3 text-[13px]" style={{ maxWidth: "100%" }}>
                <code className="block leading-6" style={{ display: "block", maxWidth: "100%" }}>{pretty}</code>
              </pre>
            </div>
          </div>
        );
      } catch {
        // fall through to fence parsing
      }
    }

    // 2) Parse fenced code blocks (always on)
    const elements: ReactNode[] = [];
    const codeRegex = /```([a-zA-Z0-9_-]+)?\n([\s\S]*?)```/g;
    let lastIndex = 0;
    let match: RegExpExecArray | null;
    while ((match = codeRegex.exec(text)) !== null) {
      const [full, langRaw, code] = match;
      const start = match.index;
      const end = start + full.length;
      if (start > lastIndex) {
        const before = text.slice(lastIndex, start);
        if (before.trim().length > 0) {
          elements.push(
            <p key={`t-${lastIndex}`} className="whitespace-pre-wrap break-words leading-relaxed">
              {before}
            </p>
          );
        }
      }
      const lang = (langRaw || "code").toLowerCase();
      const codeKey = `code-${messageId ?? "msg"}-${start}`;
      elements.push(
        <div key={`c-${start}`} className="my-2 overflow-hidden rounded-lg border border-white/10 bg-black/30">
          <div className="flex items-center justify-between border-b border-white/10 bg-black/20 px-3 py-1.5 text-[11px] text-gray-300">
            <span className="uppercase tracking-wider">{lang}</span>
            <button
              type="button"
              aria-label="Copy code"
              title="Copy code"
              onClick={async () => {
                try {
                  await navigator.clipboard.writeText(String(code));
                  setCopiedId(codeKey);
                  window.setTimeout(() => {
                    setCopiedId((prev) => (prev === codeKey ? null : prev));
                  }, 2000);
                } catch {
                  // noop
                }
              }}
              className="rounded p-1 text-gray-300/80 transition hover:bg-white/10 hover:text-white"
            >
              {copiedId === codeKey ? (
                <svg className="h-4 w-4 text-emerald-400" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M5 13l4 4L19 7" stroke="currentColor" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round" />
                </svg>
              ) : (
                <svg className="h-4 w-4" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M9 9h9v12H9z" stroke="currentColor" strokeWidth="1.5" fill="currentColor" opacity="0.2" />
                  <path d="M6 3h9v12H6z" stroke="currentColor" strokeWidth="1.5" fill="currentColor" />
                </svg>
              )}
            </button>
          </div>
          <pre className="overflow-x-auto p-3 text-[13px]" style={{ maxWidth: "100%" }}><code className="block leading-6" style={{ display: "block", maxWidth: "100%" }}>{code}</code></pre>
        </div>
      );
      lastIndex = end;
    }
    if (elements.length > 0) {
      if (lastIndex < text.length) {
        const rest = text.slice(lastIndex);
        if (rest.trim().length > 0) {
          elements.push(
            <p key={`t-${lastIndex}-end`} className="whitespace-pre-wrap break-words leading-relaxed">
              {rest}
            </p>
          );
        }
      }
      return <div className="message-prose max-w-none">{elements}</div>;
    }

    // 3) Fallback: show as text, preserving newlines
    return <p className="whitespace-pre-wrap break-words leading-relaxed">{text}</p>;
  }, [setCopiedId, copiedId]);
  const [currentChatId, setCurrentChatId] = useState<string | null>(null);

  // tRPC utilities and queries for chats
  const utils = api.useUtils();
  const { data: chatList } = api.chat.list.useQuery(undefined, { refetchOnWindowFocus: false });
  const createChat = api.chat.create.useMutation();
  const appendMessages = api.chat.appendMessages.useMutation({
    onSuccess: async () => {
      await utils.chat.list.invalidate();
    },
  });
  const removeChat = api.chat.remove.useMutation({
    onSuccess: async () => {
      await utils.chat.list.invalidate();
    },
  });

  const responseEndRef = useRef<HTMLDivElement | null>(null);

  const currentPreset = useMemo(() => {
    return presets.find((p) => (p.id ?? p.name) === selectedPresetKey) ?? null;
  }, [presets, selectedPresetKey]);

  useEffect(() => {
    responseEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, loading]);

  // Detect local model configuration in Electron runtime
  useEffect(() => {
    if (!isElectronRuntime()) return;
    let cancelled = false;
    (async () => {
      try {
        const res = await fetch('/api/model/config');
        if (!res.ok) return;
        const data = await res.json();
        if (!cancelled) setHasLocalModel(!!data?.config);
      } catch { /* ignore */ }
    })();
    return () => { cancelled = true; };
  }, []);

  // Animate generating ellipsis while awaiting AI response
  useEffect(() => {
    if (!loading) return;
    const id = setInterval(() => setGenDots((d) => (d % 3) + 1), 500);
    return () => clearInterval(id);
  }, [loading]);

  const autoResize = useCallback(() => {
    const el = inputRef.current;
    if (!el) return;
    el.style.height = "auto";
    const max = MAX_INPUT_HEIGHT;
    const needed = Math.min(el.scrollHeight, max);
    el.style.height = `${needed}px`;
    el.style.overflowY = el.scrollHeight > max ? "auto" : "hidden";
  }, [MAX_INPUT_HEIGHT]);

  // Shrink back down when input becomes empty (e.g., after send or manual clear)
  useEffect(() => {
    if (input.trim().length === 0) {
      const el = inputRef.current;
      if (el) {
        el.style.height = 'auto';
        el.style.overflowY = 'hidden';
      }
    }
  }, [input]);

  // Close sidebar on Escape
  useEffect(() => {
    if (!sidebarOpen) return;
    // Escape should only close on mobile viewports.
    if (typeof window === 'undefined') return;
    const isDesktop = window.matchMedia('(min-width: 768px)').matches;
    if (isDesktop) return; // Do nothing on desktop.
    const onKey = (e: KeyboardEvent) => {
      if (e.key === "Escape") setSidebarOpen(false);
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [sidebarOpen]);

  // Keep sidebar forced open whenever switching to desktop viewport.
  useEffect(() => {
    if (typeof window === 'undefined') return;
    const mq = window.matchMedia('(min-width: 768px)');
    const ensureOpen = () => { if (mq.matches) setSidebarOpen(true); };
    ensureOpen();
    mq.addEventListener('change', ensureOpen);
    return () => mq.removeEventListener('change', ensureOpen);
  }, []);

  useEffect(() => {
    const el = inputRef.current;
    if (!el) return;
    el.style.height = "auto";
    autoResize();
  }, [autoResize]);

  useEffect(() => {
    const load = async () => {
      setLoadingPresets(true);
      try {
        const [res, defRes] = await Promise.all([
          fetch("/api/presets"),
          fetch("/api/presets/default").catch(() => null),
        ]);
        let defaultId: string | null = null;
        if (defRes && defRes.ok) {
          const d = await defRes.json().catch(() => ({}));
          defaultId = typeof d?.defaultPresetId === "string" ? d.defaultPresetId : null;
        }
        setDefaultPresetId(defaultId);
        if (res.ok) {
          const data = await res.json();
          const list = data.presets ?? [];
          setPresets(list);
          // Auto-select default or first preset
          if (!selectedPresetKey) {
            const pick = (defaultId && list.find((p: any) => p.id === defaultId)) || list[0] || null;
            if (pick) {
              setSelectedPresetKey(pick.id ?? pick.name);
              const p = list.find((x: any) => (x.id ?? x.name) === (pick.id ?? pick.name));
              if (p) applyPreset(p);
            }
          }
        }
      } finally {
        setLoadingPresets(false);
      }
    };
    void load();
  }, []);

  const reloadPresets = useCallback(async () => {
    setLoadingPresets(true);
    try {
      const res = await fetch("/api/presets");
      if (res.ok) {
        const data = await res.json();
        setPresets(data.presets ?? []);
      }
    } finally {
      setLoadingPresets(false);
    }
  }, []);

  // Optional: restore last opened chat id from local storage (no writes back)
  // Defer restoring last chat until chat list & session ready to avoid race with auth/protected procedures
  const initialChatIdRef = useRef<string | null>(null);
  const restoredLastChatRef = useRef(false);
  useEffect(() => {
    try {
      initialChatIdRef.current = localStorage.getItem('pc_current_chat');
    } catch {
      initialChatIdRef.current = null;
    }
  }, []);

  // We'll declare selectChat then run an effect to auto-load previous chat.

  const canSend = useMemo(() => input.trim().length > 0 && !loading, [input, loading]);
  const applyPreset = useCallback((p: { name: string; mode: Mode; taskType: TaskType; options?: any }) => {
    setPresetName(p.name);
    setMode(p.mode);
    setTaskType(p.taskType);
    const o = p.options ?? {};
    if (o.tone) setTone(o.tone);
    if (o.detail) setDetail(o.detail);
    if (o.format) setFormat(o.format);
    setLanguage(o.language ?? "English");
    setTemperature(typeof o.temperature === "number" ? o.temperature : 0.7);
    setStylePreset(o.stylePreset ?? "photorealistic");
    setAspectRatio(o.aspectRatio ?? "1:1");
    setIncludeTests(!!o.includeTests);
    setRequireCitations(!!o.requireCitations);
  }, []);

  const startNewChat = useCallback(() => {
    setMessages([]);
    setInput("");
    setError(null);
    setCurrentChatId(null);
    initialChatIdRef.current = null;
    restoredLastChatRef.current = true; // prevent restoration effect later
    try { localStorage.removeItem("pc_current_chat"); } catch {}
    window.scrollTo({ top: 0, behavior: "smooth" });
  }, []);

  
  

  const savePreset = useCallback(async () => {
    const name = presetName.trim();
    if (!name) {
      setError("Please enter a preset name");
      return;
    }
    try {
      const res = await fetch("/api/presets", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name,
          mode,
          taskType,
          options: {
            tone,
            detail,
            format,
            language: language || undefined,
            temperature,
            stylePreset: taskType === "image" ? stylePreset : undefined,
            aspectRatio: taskType === "image" ? aspectRatio : undefined,
            includeTests: taskType === "coding" ? includeTests : undefined,
            requireCitations: taskType === "research" ? requireCitations : undefined,
          },
        }),
      });
      if (!res.ok) throw new Error("Failed to save preset");
      const data = await res.json();
      const updated = presets.filter((p) => p.name !== data.preset.name);
      updated.unshift(data.preset);
      setPresets(updated);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
    }
  }, [presetName, mode, taskType, tone, detail, format, language, temperature, stylePreset, aspectRatio, includeTests, requireCitations, presets]);

  const ensureChatId = useCallback(async (firstLineForTitle?: string) => {
    // Only trust currentChatId if we've actually loaded messages for it (prevents stale id after failed restore)
    if (currentChatId && lastLoadedChatIdRef.current === currentChatId) {
      const list = chatList ?? (await utils.chat.list.fetch()).map((c: any) => ({ id: c.id }));
      const exists = Array.isArray(list) && list.some((c: any) => c.id === currentChatId);
      if (exists) return currentChatId;
    }
    setCurrentChatId(null);
    lastLoadedChatIdRef.current = null;
    try { localStorage.removeItem("pc_current_chat"); } catch {}
    const title = (firstLineForTitle ?? "").slice(0, 40) || "New chat";
    const created = await createChat.mutateAsync({ title });
    setCurrentChatId(created.id);
    lastLoadedChatIdRef.current = created.id;
    try { localStorage.setItem("pc_current_chat", created.id); } catch {}
    return created.id;
  }, [currentChatId, createChat, chatList, utils.chat.list]);

  const send = useCallback(async () => {
    if (!canSend) return;
    const text = input.trim();
    setInput("");
    // Immediately reset height so it shrinks without waiting for rerender/layout thrash
    const el = inputRef.current;
    if (el) {
      el.style.height = 'auto';
      el.style.overflowY = 'hidden';
    }
    setError(null);
    // Ensure chat exists (create in DB if needed)
    let chatId: string;
    try {
      chatId = await ensureChatId(text);
    } catch (e) {
      setError(e instanceof Error ? e.message : "Failed to start chat");
      return;
    }
    const userMsg: MessageItem = { id: crypto.randomUUID(), role: "user", content: text };
    setMessages((m) => {
      // Cap chat at 50 messages
      const next = [...m, userMsg];
      return next.slice(Math.max(0, next.length - 50));
    });
    // Append user message to DB (cap enforced server-side)
    try {
      await appendMessages.mutateAsync({ chatId, messages: [{ id: userMsg.id, role: userMsg.role, content: userMsg.content }], cap: 50 });
    } catch (e) {
      console.error('Failed to save user message:', e);
      // Keep UI responsive even if DB append fails
    }
    setLoading(true);
    try {
      const base = process.env.NEXT_PUBLIC_BASE_PATH || "";
  const useStreaming = isElectronRuntime() && hasLocalModel; // only stream when a local model is actually configured
  if (useStreaming) {
        // Streaming via SSE
        const controller = new AbortController();
  const res = await fetch(`/api/googleai/chat/stream`, {
          method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              input: text,
              mode,
              taskType,
              options: { tone, detail, format, language: language || undefined, temperature, stylePreset: taskType === 'image' ? stylePreset : undefined, aspectRatio: taskType === 'image' ? aspectRatio : undefined, includeTests: taskType === 'coding' ? includeTests : undefined, requireCitations: taskType === 'research' ? requireCitations : undefined }
            }),
            signal: controller.signal
        });
        if (!res.ok || !res.body) throw new Error('Stream request failed');
        const reader = res.body.getReader();
  let assistantId = crypto.randomUUID();
  let assistantContentBuffer = '';
  setMessages(m => [...m, { id: assistantId, role: 'assistant', content: '' }]);
        const decoder = new TextDecoder();
        let buffer = '';
        while (true) {
          const { done, value } = await reader.read();
            if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const parts = buffer.split('\n\n');
          buffer = parts.pop() || '';
          for (const p of parts) {
            if (!p.startsWith('data:')) continue;
            const payload = p.slice(5).trim();
            try {
              const obj = JSON.parse(payload);
              if (obj.delta) {
                assistantContentBuffer += obj.delta;
                const delta = obj.delta; // capture
                setMessages(m => m.map(msg => msg.id === assistantId ? { ...msg, content: msg.content + delta } : msg));
              } else if (obj.done) {
                // persist using accumulated buffer to avoid stale closure
                const finalContent = assistantContentBuffer;
                try { 
                  await appendMessages.mutateAsync({ chatId, messages: [{ id: assistantId, role: 'assistant', content: finalContent }], cap: 50 }); 
                } catch (e) { 
                  console.error('Failed to save streaming assistant message:', e); 
                }
              } else if (obj.error) {
                const errMsg = obj.error as string;
                // Surface error inside the assistant placeholder instead of blank output
                setMessages(m => m.map(msg => msg.id === assistantId ? { ...msg, content: `Error: ${errMsg}` } : msg));
                setError(errMsg);
                // Finish early
                controller.abort();
              }
            } catch {
              // ignore malformed
            }
          }
        }
      } else {
  const res = await fetch(`${base}/api/googleai/chat`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            input: text,
            mode,
            taskType,
            options: {
              tone,
              detail,
              format,
              language: language || undefined,
              temperature,
              stylePreset: taskType === 'image' ? stylePreset : undefined,
              aspectRatio: taskType === 'image' ? aspectRatio : undefined,
              includeTests: taskType === 'coding' ? includeTests : undefined,
              requireCitations: taskType === 'research' ? requireCitations : undefined,
            },
          }),
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.error ?? 'Request failed');
        const assistantMsg: MessageItem = { id: crypto.randomUUID(), role: 'assistant', content: data.output as string };
        setMessages(m => { const next = [...m, assistantMsg]; return next.slice(Math.max(0, next.length - 50)); });
        try { 
          await appendMessages.mutateAsync({ chatId, messages: [{ id: assistantMsg.id, role: assistantMsg.role, content: assistantMsg.content }], cap: 50 }); 
        } catch (e) { 
          console.error('Failed to save non-streaming assistant message:', e); 
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
    } finally {
      setLoading(false);
    }
  }, [canSend, input, mode, taskType, tone, detail, format, language, temperature, stylePreset, aspectRatio, includeTests, requireCitations, ensureChatId, appendMessages, hasLocalModel]);

  const onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      void send();
    }
  };

  const [loadingChatId, setLoadingChatId] = useState<string | null>(null);
  const lastLoadedChatIdRef = useRef<string | null>(null);
  const selectChat = useCallback(async (id: string) => {
    setLoadingChatId(id);
    try {
      if (!chatList) void utils.chat.list.invalidate();
      const data = await utils.chat.get.fetch({ chatId: id, limit: 50 });
      const loaded: MessageItem[] = data.messages.map((m: { id: string; role: string; content: string; userFeedback?: 'like' | 'dislike' }) => ({ id: m.id, role: m.role as any, content: m.content, userFeedback: m.userFeedback }));
      setMessages(loaded);
      setCurrentChatId(id);
      lastLoadedChatIdRef.current = id;
      setInput('');
      try { localStorage.setItem('pc_current_chat', id); } catch {}
      requestAnimationFrame(() => responseEndRef.current?.scrollIntoView({ behavior: 'smooth' }));
    } catch (err) {
      console.warn('Failed to load chat', err);
      // show minimal inline error
      setError('Failed to load chat');
      if (currentChatId === id) {
        setCurrentChatId(null);
        lastLoadedChatIdRef.current = null;
      }
    } finally {
      setLoadingChatId(null);
    }
  }, [chatList, utils.chat.get, utils.chat.list, currentChatId]);

  // When chat list loads, attempt to load last opened chat exactly once
  useEffect(() => {
    if (restoredLastChatRef.current) return;
    if (!chatList) return;
    if (currentChatId) { restoredLastChatRef.current = true; return; }
    const target = initialChatIdRef.current;
    if (target && (chatList as any[]).some(c => c.id === target)) {
      restoredLastChatRef.current = true;
      void selectChat(target);
    } else {
      if (target) {
        try { localStorage.removeItem('pc_current_chat'); } catch {}
      }
      restoredLastChatRef.current = true;
    }
  }, [chatList, currentChatId, selectChat]);

  // Retry loading currentChatId if messages are still empty and we haven't succeeded yet (guarded)
  useEffect(() => {
    if (!currentChatId) return;
    if (messages.length > 0) return;
    // only retry for a short window after selection
    const t = setTimeout(() => { void selectChat(currentChatId); }, 100);
    return () => clearTimeout(t);
  }, [currentChatId, messages.length, selectChat]);

  const deleteChat = useCallback(async (id: string) => {
    try {
      await removeChat.mutateAsync({ chatId: id });
      if (currentChatId === id) {
        setCurrentChatId(null);
        setMessages([]);
      }
      await utils.chat.list.invalidate();
    } catch {
      // noop
    }
  }, [removeChat, currentChatId, utils.chat.list]);

  const copyMessage = useCallback(async (id: string, text: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedId(id);
      window.setTimeout(() => {
        setCopiedId((prev) => (prev === id ? null : prev));
      }, 2000);
    } catch {
      // noop
    }
  }, []);

  return (
    <div className="relative flex h-svh w-full overflow-hidden">
    {/* Sidebar backdrop (mobile only) */}
      <div
        className={cn(
          "fixed inset-0 z-30 bg-black/50 transition-opacity md:hidden",
          sidebarOpen ? "opacity-100 visible" : "opacity-0 invisible pointer-events-none"
        )}
        onClick={() => setSidebarOpen(false)}
      />

      {/* Sidebar */}
      <div
        className={cn(
      // Mobile: slide-over controlled by state; Desktop: always visible static column
      "fixed inset-y-0 left-0 z-40 w-80 -translate-x-full transform transition-transform duration-200 md:sticky md:top-0 md:h-svh md:inset-auto md:transform-none md:shrink-0 md:overflow-y-auto",
      sidebarOpen ? "translate-x-0" : "-translate-x-full",
      // Ensure always visible on desktop regardless of state
      "md:translate-x-0"
        )}
      >
  <FiltersSidebar
          user={user}
          // Close handler only relevant for mobile; ignored on desktop
          onClose={() => { if (typeof window !== 'undefined' && !window.matchMedia('(min-width: 768px)').matches) setSidebarOpen(false); }}
          openAccount={() => setAccountOpen(true)}
          openInfo={() => setInfoOpen(true)}
          presets={presets}
          selectedPresetKey={selectedPresetKey}
          setSelectedPresetKey={setSelectedPresetKey}
          loadingPresets={loadingPresets}
          applyPreset={applyPreset}
          savePreset={savePreset}
          refreshPresets={reloadPresets}
          defaultPresetId={defaultPresetId}
          setDefaultPresetId={setDefaultPresetId}
          presetName={presetName}
          setPresetName={setPresetName}
          chats={useMemo(() => (chatList ?? []).map((c: { id: string; title?: string | null; updatedAt: string | Date; messageCount?: number; _count?: { messages: number } }) => ({ id: c.id, title: c.title ?? "Untitled", updatedAt: (typeof c.updatedAt === "string" ? new Date(c.updatedAt).getTime() : (c.updatedAt as Date).getTime()), messageCount: c.messageCount ?? (c._count?.messages ?? 0) })), [chatList])}
          currentChatId={currentChatId}
          onSelectChat={selectChat}
          onDeleteChat={deleteChat}
          taskType={taskType}
          setTaskType={(v) => setTaskType(v)}
          mode={mode}
          setMode={(v) => setMode(v)}
          tone={tone}
          setTone={(v) => setTone(v)}
          detail={detail}
          setDetail={(v) => setDetail(v)}
          format={format}
          setFormat={(v) => setFormat(v)}
          language={language}
          setLanguage={setLanguage}
          temperature={temperature}
          setTemperature={setTemperature}
          stylePreset={stylePreset}
          setStylePreset={setStylePreset}
          aspectRatio={aspectRatio}
          setAspectRatio={setAspectRatio}
          includeTests={includeTests}
          setIncludeTests={setIncludeTests}
          requireCitations={requireCitations}
          setRequireCitations={setRequireCitations}
        />
      </div>

      {/* Chat area */}
      <div className="flex flex-1 min-h-0 flex-col">
        <div className="sticky top-0 z-10 flex items-center justify-between gap-3 border-b border-gray-800 bg-gray-900/80 px-4 py-3 backdrop-blur">
          <div className="flex items-center gap-3">
            {/* Mobile toggle button only */}
            <button
              type="button"
              className="md:hidden rounded-md border border-gray-700 px-2 py-1 text-sm text-gray-200 transition hover:border-blue-500 hover:text-white"
              onClick={() => setSidebarOpen((v) => !v)}
              aria-label="Open filters sidebar"
              title="Toggle sidebar"
            >
              <Icon name="bars" />
            </button>
            <div className="flex items-center text-lg font-semibold text-blue-400">
              <Image src="/icon.png" alt="PromptCrafter icon" width={20} height={20} className="w-4 h-4 mr-2" priority />
              PromptCrafter{modelDisplay && <span className="ml-2 text-sm font-normal text-gray-400">- {modelDisplay}</span>}
            </div>
          </div>
        </div>

        {/* Mobile preset row below header */}
        <div className="sm:hidden border-b border-gray-800 bg-gray-900/80 px-3 py-2">
          <div className="mx-auto w-full max-w-3xl">
            <div className="flex items-center gap-2">
              <span className="text-[10px] uppercase tracking-wider text-gray-400">Preset</span>
              <div className="relative flex-1">
                <span className="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-xs">{defaultPresetId && currentPreset?.id === defaultPresetId ? <Icon name="star" className="text-amber-400" /> : <Icon name="sliders" />}</span>
                <CustomSelect
                  value={selectedPresetKey}
                  onChange={(key) => {
                    setSelectedPresetKey(key);
                    const p = presets.find((x) => (x.id ?? x.name) === key);
                    if (p) applyPreset(p);
                  }}
                  options={[
                    { value: "", label: "Apply preset…", disabled: true },
                    ...presets.map((p) => ({
                      value: p.id ?? p.name,
                      label: `${(defaultPresetId && p.id === defaultPresetId) ? "(Default) " : ""}${p.name}`
                    }))
                  ]}
                  aria-label="Apply preset"
                  title={currentPreset?.name || "Apply preset"}
                  className="w-full pl-8 pr-7 py-2 text-xs rounded-full"
                />
                <span className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-[10px] text-gray-400">▾</span>
              </div>
            </div>
          </div>
        </div>

        <div className="flex-1 min-h-0 overflow-y-auto p-3 md:p-4">
          <div className="mx-auto w-full max-w-3xl">
            {messages.length === 0 ? (
              <p className="text-sm text-gray-400">Start by typing a request below and press Send.</p>
            ) : (
              <div className="flex flex-col gap-3">
                {messages.map((m) => {
                  const isUser = m.role === "user";
                  return (
                    <div key={m.id} className={cn("flex w-full", isUser ? "justify-end" : "justify-start")}>
                      <div
                        className={
                          "relative min-w-0 max-w-[92vw] sm:max-w-[85%] md:max-w-[80%] whitespace-pre-wrap break-words rounded-2xl px-4 py-3 pr-9 text-sm shadow-sm transition-[max-width,transform,background-color] duration-200 " +
                          (isUser
                            ? "rounded-br-sm bg-indigo-600 text-white"
                            : "rounded-bl-sm bg-gray-800 text-gray-100")
                        }
                      >
                        {renderMessageContent(m.content, m.id)}
                        <button
                          type="button"
                          aria-label="Copy message"
                          onClick={() => void copyMessage(m.id, m.content)}
                          className="absolute right-2 top-2 rounded p-1 opacity-70 transition-opacity hover:bg-white/10 hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-white/20"
                        >
                          {copiedId === m.id ? (
                            <svg className="h-4 w-4 text-emerald-400" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                              <path d="M5 13l4 4L19 7" stroke="currentColor" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <svg className="h-4 w-4" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                              <path d="M9 9h9v12H9z" stroke="currentColor" strokeWidth="1.5" fill="currentColor" opacity="0.2" />
                              <path d="M6 3h9v12H6z" stroke="currentColor" strokeWidth="1.5" fill="currentColor" />
                            </svg>
                          )}
                        </button>
                        {!isUser && (
                          <div className="mt-3 -mb-1 border-t border-white/5 pt-2">
                            <MessageFeedback
                              messageId={m.id}
                              initialFeedback={m.userFeedback ?? null}
                              onChange={(fb) => {
                                setMessages(prev => prev.map(msg => msg.id === m.id ? { ...msg, userFeedback: fb ?? undefined } : msg));
                              }}
                            />
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
                {loading && (
                  <div className="self-start">
                    <div className="relative max-w-[80%] rounded-2xl rounded-bl-sm bg-gray-800 px-4 py-3 pr-9 text-sm text-gray-100 shadow-sm">
                      <div className="flex items-center gap-2">
                        <div className="h-4 w-4 animate-spin rounded-full border-2 border-white/30 border-t-white" />
                        <span>Generating{".".repeat(genDots)}</span>
                      </div>
                    </div>
                  </div>
                )}
                <div ref={responseEndRef} />
              </div>
            )}
            {error && (
              <div className="mt-3 rounded-md border border-red-700 bg-red-900/30 p-3 text-sm text-red-300">{error}</div>
            )}
          </div>
        </div>

        <div className="sticky bottom-0 z-10 border-t border-gray-800 bg-gray-900/80 px-3 py-3 backdrop-blur md:px-4">
          <div className="mx-auto w-full max-w-3xl">
            <div className="flex items-end gap-3">
              <div className="relative hidden sm:block">
                <label className="sr-only">Preset</label>
                <span className="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-xs">{defaultPresetId && currentPreset?.id === defaultPresetId ? <Icon name="star" className="text-amber-400" /> : <Icon name="sliders" />}</span>
                <CustomSelect
                  value={selectedPresetKey}
                  onChange={(key) => {
                    setSelectedPresetKey(key);
                    const p = presets.find((x) => (x.id ?? x.name) === key);
                    if (p) applyPreset(p);
                  }}
                  options={[
                    { value: "", label: "Apply preset…", disabled: true },
                    ...presets.map((p) => ({
                      value: p.id ?? p.name,
                      label: `${(defaultPresetId && p.id === defaultPresetId) ? "(Default) " : ""}${p.name}`
                    }))
                  ]}
                  aria-label="Apply preset"
                  title={currentPreset?.name || "Apply preset"}
                  className="w-64 h-11 shrink-0 pl-8 pr-8 text-xs rounded-2xl"
                />
                <span className="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 text-[10px] text-gray-400">▾</span>
              </div>
              <textarea
                ref={inputRef}
                value={input}
                onInput={autoResize}
                onChange={(e) => {
                  setInput(e.target.value);
                  // Ensure smooth growth while typing even if onInput coalesces
                  autoResize();
                }}
                onKeyDown={onKeyDown}
                placeholder={mode === "build" ? "Describe the prompt you want to build..." : "Paste a prompt to enhance it..."}
                className="flex-1 resize-none rounded-2xl border border-white/10 bg-gray-900/60 p-3 text-sm text-gray-100 shadow-sm transition-[height] duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-400/50"
                rows={1}
                style={{ maxHeight: MAX_INPUT_HEIGHT, overflowY: "auto" }}
              />
              <button
                onClick={() => void send()}
                disabled={!canSend}
                className="rounded-lg bg-indigo-600 px-5 py-2.5 font-semibold text-white shadow-sm transition enabled:hover:bg-indigo-700 disabled:opacity-60"
              >
                Send
              </button>
              <button
                type="button"
                onClick={startNewChat}
                className="flex h-11 w-11 items-center justify-center rounded-lg border border-white/10 bg-gray-800 text-white shadow-sm transition hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-indigo-400/50"
                aria-label="Start a new chat"
                title="New chat"
              >
                <span className="text-lg font-light">+</span>
              </button>
            </div>
          </div>
        </div>

        {(accountOpen || infoOpen) && (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center"
            aria-modal="true"
            role="dialog"
            aria-label={infoOpen ? "Prompt settings info" : "Saved Data"}
          >
            <div className="absolute inset-0 bg-black/60" onClick={() => { setAccountOpen(false); setInfoOpen(false); }} />
            <div
              className="relative z-10 w-[92vw] max-w-xl rounded-xl border border-white/10 bg-gray-900 p-5 text-gray-100 shadow-2xl max-h-[85vh] overflow-y-auto"
              onClick={(e) => e.stopPropagation()}
            >
              <button
                type="button"
                onClick={() => { setAccountOpen(false); setInfoOpen(false); }}
                className="absolute right-3 top-3 inline-flex h-8 w-8 items-center justify-center rounded-md border border-gray-700 text-gray-300 transition hover:border-red-500 hover:text-white"
                aria-label="Close help"
                title="Close"
              >
                <Icon name="close" />
              </button>
              <div className="mb-3 text-lg font-semibold">{infoOpen ? "Prompt Settings Info" : "Saved Data"}</div>
              {infoOpen ? (
                <div className="space-y-4 text-sm">
                  <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                    <div className="font-medium">Preset Name</div>
                    <div className="mt-1 text-gray-300">The name of your preset. Use it to save, find, and reapply settings quickly.</div>
                  </div>
                  <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                    <div className="font-medium">Type</div>
                    <ul className="mt-1 list-disc space-y-1 pl-5 text-gray-300">
                      <li><strong>General</strong>: Balanced for everyday tasks.</li>
                      <li><strong>Coding</strong>: Tailored for code. <em>Include tests</em> asks the model to generate tests with solutions.</li>
                      <li><strong>Image</strong>: Generates image prompts. Configure <em>Image Style</em> (e.g., Photorealistic, Illustration) and <em>Aspect Ratio</em> (e.g., 1:1, 16:9).</li>
                      <li><strong>Research</strong>: Oriented for factual outputs. <em>Require citations</em> asks for sources where possible.</li>
                      <li><strong>Writing</strong>: For articles, stories, emails, etc.</li>
                      <li><strong>Marketing</strong>: For ads, landing copy, and campaigns.</li>
                    </ul>
                  </div>
                  <div className="grid grid-cols-1 gap-3">
                    <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                      <div className="font-medium">Mode</div>
                      <ul className="mt-1 list-disc space-y-1 pl-5 text-gray-300">
                        <li><strong>Build</strong>: Create a prompt from your description.</li>
                        <li><strong>Enhance</strong>: Improve or refactor an existing prompt.</li>
                      </ul>
                    </div>
                    <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                      <div className="font-medium">Tone</div>
                      <div className="mt-1 text-gray-300">Style of voice: <em>Neutral, Friendly, Formal, Technical, Persuasive</em>.</div>
                    </div>
                    <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                      <div className="font-medium">Detail</div>
                      <div className="mt-1 text-gray-300">How comprehensive the output should be: <em>Brief, Normal, Detailed</em>.</div>
                    </div>
                    <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                      <div className="font-medium">Format</div>
                      <div className="mt-1 text-gray-300">Preferred output: <em>Plain</em> text, <em>Markdown</em>, or <em>JSON</em>.</div>
                    </div>
                    <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                      <div className="font-medium">Language</div>
                      <div className="mt-1 text-gray-300">Choose output language: English, Dutch, Arabic, Mandarin Chinese, Spanish, French, Russian, Urdu.</div>
                    </div>
                    <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                      <div className="font-medium">Temperature</div>
                      <div className="mt-1 text-gray-300">Controls randomness (0.1–1.0). Lower = more focused and deterministic; higher = more creative.</div>
                    </div>
                  </div>
                </div>
              ) : (
                <div className="space-y-4 text-sm">
                  <div className="flex items-center gap-3 rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                    <div className="flex h-10 w-10 items-center justify-center rounded-full bg-gray-700 text-sm text-white"><Icon name="db" /></div>
                    <div className="min-w-0">
                      <div className="truncate text-sm font-medium text-gray-100">Saved Data</div>
                      <div className="text-xs text-gray-400">Manage locally stored chats & presets.</div>
                    </div>
                  </div>
                  <div className="rounded-lg border border-gray-800 bg-gray-800/40 p-3">
                    <div className="font-medium">Privacy</div>
                    <div className="mt-2 text-gray-300">Delete all your chats and presets from this app.</div>
                    <button
                      type="button"
                      className="mt-3 rounded-md border border-red-600 bg-red-600/10 px-3 py-2 text-xs font-semibold text-red-300 transition hover:bg-red-600/20"
                      onClick={() => {
                        const box = document.createElement("div");
                        box.className = "fixed inset-0 z-50 flex items-center justify-center";
                        box.innerHTML = `
                          <div class=\"absolute inset-0 bg-black/60\"></div>
                          <div class=\"relative z-10 w-[92vw] max-w-sm rounded-xl border border-white/10 bg-gray-900 p-4 text-gray-100 shadow-2xl\">\n                            <div class=\"text-base font-semibold mb-2\">Delete all data?</div>\n                            <div class=\"text-sm text-gray-300\">This will delete all chats and presets. This cannot be undone.</div>\n                            <div class=\"mt-4 flex items-center justify-end gap-2\">\n                              <button id=\"pc_cancel\" class=\"rounded-md border border-gray-600 bg-gray-800 px-3 py-1.5 text-sm\">Cancel</button>\n                              <button id=\"pc_confirm\" class=\"rounded-md border border-red-600 bg-red-600/20 px-3 py-1.5 text-sm text-red-200\">Delete</button>\n                            </div>\n                          </div>`;
                        document.body.appendChild(box);
                        const remove = () => box.remove();
                        document.getElementById("pc_cancel")?.addEventListener("click", () => remove(), { once: true });
                        document.getElementById("pc_confirm")?.addEventListener("click", async () => {
                          try {
                            try {
                              const list = await utils.chat.list.fetch();
                              for (const c of list ?? []) {
                                try { await removeChat.mutateAsync({ chatId: c.id }); } catch {}
                              }
                            } catch {}
                            try {
                              const res = await fetch('/api/presets');
                              const data = await res.json();
                              const ps = Array.isArray(data?.presets) ? data.presets : [];
                              for (const p of ps) {
                                try { await fetch(`/api/presets?id=${encodeURIComponent(p.id)}`, { method: 'DELETE' }); } catch {}
                              }
                            } catch {}
                          } finally { remove(); }
                        }, { once: true });
                      }}
                    >
                      Delete all chat history and saved prompt presets
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


